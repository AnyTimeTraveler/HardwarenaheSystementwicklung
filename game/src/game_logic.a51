NAME game

SEG_GAME_LOGIC SEGMENT CODE

; EXTRN CODE (DAT_LEVEL_TICKS, DAT_TETRIS_PIECES, PFUN_SETUP_TIMERS, PFUN_DETECT_BAUDRATE)
; EXTRN DATA (SCREEN_REFRESH_CURRENT_ROW, CURRENT_PIECE_INDEX)
; EXTRN DATA (CURRENT_PIECE_ROT_INDEX, CURRENT_PIECE_V_POS, CURRENT_PIECE_H_POS)
; EXTRN DATA (CP, GAMETICK_SUB_COUNTER, CURRENT_LEVEL, CURRENT_PIECE_DECOMPRESSED)
; EXTRN IDATA (GAMESCREEN, COLOURMAP, STACK)
; EXTRN DATA (PIECE_SIZE)
; EXTRN BIT (BIT_CURRENT_COLOR, LED)

JEQ MACRO REGISTER, VALUE, FUNCTION
LOCAL   NOT_EQUAL
    CJNE REGISTER, #VALUE, NOT_EQUAL
    CALL FUNCTION
    JMP PJMP_GAMELOOP
NOT_EQUAL:
ENDM

EXTRN CODE (GS_PRE_GAME, GS_PLAYING, GS_ROW_CLEARING, GS_LOST)
EXTRN DATA (GAMESTATE)
PUBLIC PJMP_GAMELOOP, PJMPI_SUB_GAMETICK, PFUN_MOVE_LEFT, PFUN_MOVE_RIGHT, PFUN_ROTATE_RIGHT

RSEG SEG_GAME_LOGIC
PJMP_GAMELOOP:
    ; wait for the next gametick
    JNB BIT_RUN_GAMETICK, $
    CLR BIT_RUN_GAMETICK

    MOV R1, GAMESTATE
    JEQ R1, GS_FIRST_RUN, FUN_RESET_GAME
    JEQ R1, GS_PRE_GAME, FUN_PRE_GAME_GAMETICK
    JEQ R1, GS_PLAYING, FUN_GAMETICK
    JEQ R1, GS_ROW_CLEARING, FUN_ANIMATE_ROW_CLEARING
    JEQ R1, GS_LOST, FUN_ANIMATE_GAME_END

    MOV A, #0xDE
    CALL PFUN_SERIAL_WRITE
    MOV A, R1
    CALL PFUN_SERIAL_WRITE

    JMP PJMP_GAMELOOP


FUN_RESET_GAME:
    ; set level to idle animation interval
    MOV CURRENT_LEVEL, #0
    MOV GAMESTATE, #GS_PRE_GAME
    RET

FUN_START_GAME:
    MOV CURRENT_LEVEL, #1
    ; Put first piece on the screen
    MOV CURRENT_PIECE_INDEX, #5
    MOV CURRENT_PIECE_ROT_INDEX, #0
    CALL FUN_DECOMPRESS_PIECE
    MOV CURRENT_PIECE_V_POS, #0
    CALL FUN_ADD_PIECE
    CALL FUN_ADD_PIECE_COLOR

    MOV GAMESTATE, #GS_PLAYING
    RET


FUN_SELECT_NEXT_PIECE:
    MOV A, CURRENT_PIECE_INDEX
    INC A
    CJNE A, #7, STORE_NEXT_PIECE
    MOV A, #0
STORE_NEXT_PIECE:
    MOV CURRENT_PIECE_INDEX, A
    JB BIT_CURRENT_COLOR, CURRENT_COLOR_SET
    SETB BIT_CURRENT_COLOR
    RET
CURRENT_COLOR_SET:
    CLR BIT_CURRENT_COLOR
    RET

FUN_RESET_GAME:
    MOV GAMESTATE, #GS_PLAYING
    JMP FUN_DRAW_BACKGROUND


PJMPI_SUB_GAMETICK:
    ; Reload with DF76
    ; for 200 Interrupts per Second
    ; Actually, reload with D20C
    ; for one tick every 7 ms (one gametick on lv 15) and scale from there
    MOV TH1, #0xD2
    MOV TL1, #0x0C

    ; decrement gametick subcounter
    DEC GAMETICK_SUB_COUNTER
    MOV A, GAMETICK_SUB_COUNTER
    ; check if sub counter has been reached
    JNZ SUB_GAMETICK_RETURN

    ; load max ticks for current level
    MOV DPTR, #DAT_LEVEL_TICKS
    MOV A, CURRENT_LEVEL
    MOVC A, @A + DPTR
    MOV GAMETICK_SUB_COUNTER, A

    SETB BIT_RUN_GAMETICK

SUB_GAMETICK_RETURN:
    RETI


FUN_GAMETICK:
    ; remove the piece from the board
    CALL FUN_REMOVE_PIECE
MOVE_PIECE_DOWN:
    INC CURRENT_PIECE_V_POS
    CALL FUN_CHECK_COLLISION
    JNC CAN_MOVE_DOWN
    DEC CURRENT_PIECE_V_POS
    MOV A, CURRENT_PIECE_V_POS
    CJNE A, #0, STILL_ROOM
    ; when we arrive here, the game has been lost
    ; stop new pieces from spawning
    ; TODO: switch gamestate (also todo) to end
    CALL FUN_DRAW_BACKGROUND
    RET
STILL_ROOM:
    CALL FUN_ADD_PIECE
    CALL FUN_ADD_PIECE_COLOR
    CALL FUN_FIND_FULL_ROW
    JNC NO_ROW_FILLED
    INC CURRENT_LEVEL
    ; R1 now contains the filled row adress (left/first byte)
    PUSH AR1
    CALL FUN_MOVE_ROWS_DOWN
    POP AR1
    CALL FUN_MOVE_ROWS_DOWN_COLOR
NO_ROW_FILLED:
    MOV CURRENT_PIECE_V_POS, #0
    CALL FUN_SELECT_NEXT_PIECE
    CALL FUN_DECOMPRESS_PIECE
CAN_MOVE_DOWN:
    CALL FUN_ADD_PIECE
    CALL FUN_ADD_PIECE_COLOR
    RET


PFUN_MOVE_LEFT:
    CALL FUN_REMOVE_PIECE
    CALL FUN_SHIFT_PIECE_LEFT
    CALL FUN_CHECK_COLLISION
    ; check if no collision
    JNC KBD_RETURN
    ; otherwise undo
    CALL FUN_SHIFT_PIECE_RIGHT
    JMP KBD_RETURN


PFUN_MOVE_RIGHT:
    CALL FUN_REMOVE_PIECE
    CALL FUN_SHIFT_PIECE_RIGHT
    CALL FUN_CHECK_COLLISION
    ; check if no collision
    JNC KBD_RETURN
    ; otherwise undo
    CALL FUN_SHIFT_PIECE_LEFT
    JMP KBD_RETURN


PFUN_ROTATE_RIGHT:
    CALL FUN_REMOVE_PIECE
    CALL FUN_ROTATE_PIECE_RIGHT
    CALL FUN_CHECK_COLLISION
    ; check if no collision
    JNC KBD_RETURN
    ; otherwise undo
    CALL FUN_ROTATE_PIECE_LEFT
    JMP KBD_RETURN

KBD_RETURN:
    CALL FUN_ADD_PIECE
    CALL FUN_ADD_PIECE_COLOR
    RET

END
